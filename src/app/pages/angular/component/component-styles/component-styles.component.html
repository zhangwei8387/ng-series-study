<div class="tutorial">
    <h2 id="range-style">范围化的样式</h2>
    现在,你应该已经有了组件化开发的概念.既然是组件化开发,就涉及到一个样式范围的问题.
    <br/> 尝试思考下面几个问题:
    <ol>
        <li>在子组件中定义的样式,能否应用在父组件中?</li>
        <li>在父组件中定义的样式,能否应用在子组件中?</li>
    </ol>
    在以下示例中,我在父组件当中定义了样式
    <span class="key-word">bgColor</span>,将背景颜色设置为红色,在子组件当中定义了样式
    <span class="key-word">color</span>将字体颜色设置为蓝色.
    <br/> 在父子组件的内容中,同时应用了这两种样式,通过效果可以发现,父子组件样式互相并不影响.
    <nz-tabset>
        <nz-tab nzTitle="父组件html">
            <codemirror [(ngModel)]="code1" [config]="codemirrorConfig">
            </codemirror>
        </nz-tab>
        <nz-tab nzTitle="父组件css">
            <codemirror [(ngModel)]="code2" [config]="codemirrorConfig">
            </codemirror>
        </nz-tab>
        <nz-tab nzTitle="子组件html">
            <codemirror [(ngModel)]="code3" [config]="codemirrorConfig">
            </codemirror>
        </nz-tab>
        <nz-tab nzTitle="子组件css">
            <codemirror [(ngModel)]="code4" [config]="codemirrorConfig">
            </codemirror>
        </nz-tab>
    </nz-tabset>
    <h3>运行结果</h3>
    <nz-card class="card">
        <h1>父组件</h1>
        <span class="color bgColor">父组件的内容</span>
        <child-styles1></child-styles1>
    </nz-card>
    <h2 id="host">:host</h2>
    尝试思考这样一个问题:在子组件当中,最外面的标签是什么?通过查看元素,你会发现子组件本身就是最外部的标签.
    <br/> 那么,如何添加样式给这个边界呢?只需在子组件样式表中写以下代码即可:
    <div class="pattern">
        :host(.selector)
    </div>
    可以看到,以上模板代码中包含了两个部分,一个是
    <span class="key-word">:host</span>,意味着在整个子组件的根元素上添加样式,而小括号内的参数,其实你猜猜也应该知道是什么意思了,起到过滤作用.也就是说,只有子组件根元素上存在这个选择器类名的组件才应用这个样式,如下面这个例子
    <nz-tabset>
        <nz-tab nzTitle="父组件html">
            <codemirror [(ngModel)]="code5" [config]="codemirrorConfig">
            </codemirror>
        </nz-tab>
        <nz-tab nzTitle="子组件css">
            <codemirror [(ngModel)]="code6" [config]="codemirrorConfig">
            </codemirror>
        </nz-tab>
    </nz-tabset>
    <div class="warning">
        如果没有写
        <span class="key-word">selector</span>选择器,则为全体子组件添加host样式
    </div>
    <h3>运行结果</h3>
    <nz-card class="card">
        <h1>父组件</h1>
        <child-styles2 class="first-element"></child-styles2>
    </nz-card>
    <h2 id="ngDeep">::ng-deep</h2>
    当父组件包含子组件时,原则上各自的样式互相不污染,那如果一定要污染呢?这个时候就需要
    <span class="key-word">::ng-deep</span>,官方称之为刺穿选择器.
    <div class="info">
        我觉得 刺穿 这个名字起的非常好,具备顾名思义的特点.
    </div>
    当父组件的样式表中使用了刺穿选择器时,即可将样式应用在子组件当中.
    <nz-tabset>
        <nz-tab nzTitle="父组件html">
            <codemirror [(ngModel)]="code7" [config]="codemirrorConfig">
            </codemirror>
        </nz-tab>
        <nz-tab nzTitle="父组件css">
            <codemirror [(ngModel)]="code8" [config]="codemirrorConfig">
            </codemirror>
        </nz-tab>
        <nz-tab nzTitle="子组件html">
            <codemirror [(ngModel)]="code9" [config]="codemirrorConfig">
            </codemirror>
        </nz-tab>
    </nz-tabset>
    <h3>运行结果</h3>
    <nz-card class="card">
        <h1>父组件</h1>
        <child-styles3></child-styles3>
    </nz-card>
    <h2 id="style-talk">样式杂谈</h2>
    在这里,会讲解一些没什么太大难度,无需演示效果的内容.
    <br/>
    <h3 id="model-style">模板文件与样式文件</h3>
    在CLI自动生成的代码中,样式部分默认是使用外链样式文件,而模板文件默认也是使用外部模板的. 实际上,模板代码与样式代码都可以使用内嵌的方式.
    <br/> 而且,在模板当中(无论是哪种),都是可以直接引用css文件的.(关于这点我觉得不是很有必要,既然都提供了专门的样式字段了,何必在模板里引呢?)
    <div class="warning">
        "link 标签的 href URL 必须是相对于本应用的根路径的，而不是相对于这个组件文件的."(这是官网原话,太麻烦了,所以真心不推荐这种引样式的方式)
    </div>
    <nz-tabset>
        <nz-tab nzTitle="链接外部文件">
            <codemirror [(ngModel)]="code10" [config]="codemirrorConfig">
            </codemirror>
        </nz-tab>
        <nz-tab nzTitle="使用内嵌代码">
            <codemirror [(ngModel)]="code11" [config]="codemirrorConfig">
            </codemirror>
        </nz-tab>
    </nz-tabset>
    <div class="warning">
        注意了!在模板内嵌代码中,使用的不是单引号,是数字键1左边的符号,我在案例中使用的是单引号.是因为我的代码格式化插件数据源本身就是用这个符号包围的,如果我再次使用便会产生冲突.
    </div>
    <h3 id="import-style">引入样式文件</h3>
    尝试思考如下两个问题:
    <ol>
        <li>如果你有一个样式文件是全局都需要的怎么办?</li>
        <li>如果你有一个样式文件并不是全局都需要,但却是好多个文件共用(局部需要)怎么办?</li>
    </ol>
    为了解决第一个问题,你可以在文件
    <span class="key-word">angular.json</span>(6.0版本)中添加.直接文件内搜索
    <span class="key-word">src/styles.less</span>即可找到添加的位置.
    <br/> 如果你的版本是6.0以下的,在文件
    <span class="key-word">angular-cli.json</span>中添加,搜索
    <span class="key-word">styles.less</span>即可.
    <br/> 为了解决第二个问题,你可以在局部需要的那些样式文件中引入样式文件
    <codemirror [(ngModel)]="code12" [config]="codemirrorConfig">
    </codemirror>
    <div class="warning">
        我是指在css中引入css,这个语法在Angular当中是支持的.
    </div>
    <h2 id="control-view">控制视图的封装</h2>
    尝试思考如下几个问题:
    <ol>
        <li>Angular是如何办到组件之间样式不污染,而全局能影响的?</li>
        <li>如果我一个项目有20个页面,19个页面都需要某个样式,如果我全局引入,那么有一个页面就被污染了,如果我在19个页面样式表引入,又太麻烦,有什么兼顾的办法吗?</li>
    </ol>
    实际上,组件都提供了
    <span class="key-word">encapsulation</span>(封装)的可选项字段,一共有三种模式.
    <br/> 第一个问题,其实就是默认的模式实现的,其值为
    <span class="key-word">Emulated </span>,这是默认模式.中文官方文档在对于视图封装解释的非常好,官方译注是"只进不出，全局样式能进来，组件样式出不去".
    <br/> 第二个问题,可以使用
    <span class="key-word">Native</span>模式解决,译注"不进不出，没有样式能进来，组件样式出不去"
    <br/> 第三种模式是
    <span class="key-word">None</span>,译注"能进能出".其实这种方式会导致所有组件互相污染样式,我想不到这种方式的应用场景,如果有大神知道麻烦点拨一下.
    <codemirror [(ngModel)]="code13" [config]="codemirrorConfig">
    </codemirror>
    <div class="info">
        <span class="key-word">ViewEncapsulation</span>需要引入,属于
        <span class="key-word">@angular/core</span>包.
    </div>
</div>
<nz-anchor class="anchor">
    <nz-link nzHref="#range-style" nzTitle="范围化的样式"></nz-link>
    <nz-link nzHref="#host" nzTitle=":host"></nz-link>
    <nz-link nzHref="#ngDeep" nzTitle="::ng-deep"></nz-link>
    <nz-link nzHref="#style-talk" nzTitle="样式杂谈">
        <nz-link nzHref="#model-style" nzTitle="模板文件与样式文件"></nz-link>
        <nz-link nzHref="#import-style" nzTitle="引入样式文件"></nz-link>
        <nz-link nzHref="#control-view" nzTitle="控制视图的封装"></nz-link>
    </nz-link>
</nz-anchor>